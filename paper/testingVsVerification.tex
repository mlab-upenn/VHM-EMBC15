\subsection{Validating system behavior: Testing vs Verification}
A \emph{system} $S$ may be seen as an input-output map: $S: U^* \rightarrow Y^*$.
The \emph{input} to the system is a sequence, or \emph{string}, of values from the set $U$, and its \emph{output} is a corresponding string of values from the set $Y$.
Thus
\[u_1u_2u_3 \ldots \stackrel{S}{\rightarrow} y_1 y_2 y_3 \ldots...\]
Here we showed two infinite strings, and we consider finite input and output strings to be a special case. 

In addition, the system will have an \emph{initial state} $x_0$. 
Roughly, this describes the state of the system before receiving the first input value $u_1$. 
E.g., for a pacemaker device, this would describe the initial values for the various refractory periods, among other things.
For an electric circuit, this would describe the initial voltage values in all interconnect wires, initial values in buffers, etc.
In general, the initial state $x_0$ may take a value from some set $X_0$.

To specify what is \emph{correct} system behavior, we must specify:
\begin{itemize}
	\item The set of valid initial states in which the system can start, i.e., the set $X_0$.
	\item The allowed set of input strings. In general, not every string in $U^*$ will be considered a valid input, and we can only define correctness when the input string is a valid one.
	We denote the set of valid input strings by $A$. 
	We have $A \subset U^*$.
	\item Perhaps most importantly, we must define properties of the output strings of $S$, i.e. how should $S$ behave?
	These properties are of two types:
	\begin{enumerate}
		\item We may define properties that must hold \emph{regardless} of the input strings that lead to them. 
		\item Or we may define properties that must hold only when the system is driven by given (sets of) input strings.
	\end{enumerate}
	In general, a property is an expression involving the the inputs and output of the system.
\end{itemize}
Together, we call this these three elements \emph{the system's specification}.

\emph{\textbf{Testing}} is a method for checking that the system does indeed obey its specification. 
In testing, an algorithm will 
\begin{itemize}
	\item initialize the system to some initial state $x_0$ in $X_0$,
	\item generate sequences of input strings $\bar{u_k} \in A$, to which the system will produce output strings $\bar{y}_k$,
	\item a \emph{monitor} logs the output strings and determines whether the pair $(\bar{u}_k,\bar{y}_k)$ satisfies the specification or not.	
\end{itemize}

The generation algorithm and monitor are commonly referred to as a \emph{testbench} or test harness, and might be implemented in one piece of code. 
Because the set of valid initial states $X_0$ and the set of valid input strings $A$ may be infinite (or simply too large), the testbench must decide on how to intelligently choose a \emph{finite} number of $(x_0,\ub)$.
They must be chosen such that if the system does not produce wrong behavior with these pairs, then it is unlikely to produce errors under the \emph{full} valid set of $(x_0,\ub)$ pairs, namely, $X_0 \times A$.
This is the main challenge of testing: how to sample an infinite or large set of behaviors such that it is representative (in the above sense) of the full set of behaviors that $S$ is capable of?

Another important issue in testing is for how long to test the system: i.e. what should be the length of the $k^{th}$ string $\ub_k$? 
E.g., if $\ub_k$ has length 1000, the bug might manifest itself on $y_1\ldots y_{1001}$, but not $y_1\ldots y_{1000}$.

Regardless of testing algorithm, testing remains incomplete, in the sense that short of testing every possible behavior, bugs may lie hidden in the behavior that we did not witness.
Even when $X_0 \times A$ is finite, exhaustive testing might not be practical, because it would take too long to execute the system on every element of $X_0 \times A$.

\emph{\textbf{Verification}} refers to formal verification.
It is applicable to finite state systems\footnote{Some infinite-state systems can be formally verified after an abstraction process which essentially produces an equivalent system that has finitely many states.}, 
and requires formal semantics for the system's operation. 
Roughly, this means we must have a mathematical unambiguous definition of how the system produces its output.
A verification algorithm, or \emph{model checker}, will explore the \emph{entire finite state-space} of the system in a systematic manner. 
Intuitively, if the entire state-space has been explored in all possible ways, and no incorrect behavior has been displayed, then the system is correct. 
That is because any system behavior (any string $\yb$) is generated by having the system traverse its state-space.
Because the state-space is finite, eventually, any traversal will re-visit the same states.
Of course, if the system has memory, then this doesn't necessarily mean the same output sequence will be generated.
However, that memory itself must be finite.
Thus, verification is inherently \emph{complete}: if the model checker determines that the system is correct (under the constraints $A$ and $X_0$), then we can rest assured that that is indeed the case.
Unlike testing, there is no question of whether we missed (didn't run) an initial condition that can display a bug.
There is also no question of test duration.

Verification is computationally expensive and usually more burdensome to setup, but comes with a guarantee on the answer. 
Testing is computationally cheaper and less burdensome to setup, but the guarantees it provides are significantly weaker.
Testing, on the other hand, may be the only option for some complex systems that are beyond the capacity of today's model checkers, or which do not possess formal semantics.






