\subsection{Validating system behavior: Testing vs Verification}

\newcommand{\ub}{\bar{u}}
\newcommand{\yb}{\bar{y}}
A \emph{system} $S$ may be seen as an input-output map: $S: U^* \rightarrow Y^*$.
The \emph{input} to the system is a sequence, or \emph{string}, of values from the set $U$, and its \emph{output} is a corresponding string of values from the set $Y$.
Thus
\[u_1u_2u_3 \ldots \stackrel{S}{\rightarrow} y_1 y_2 y_3 \ldots...\]
Here we showed two infinite strings, and we consider finite input and output strings to be a special case. 

In addition, the system will have an \emph{initial state} $x_0$. 
Roughly, this describes the state of the system before receiving the first input value $u_1$. 
E.g., for a pacemaker device, this would describe the initial values for the various refractory periods, among other things.
For an electric circuit, this would describe the initial voltage values in all interconnect wires, initial values in buffers, etc.
In general, the initial state $x_0$ may take a value from some set $X_0$.

To specify what is \emph{correct} system behavior, we must specify:
\begin{itemize}
	\item The set of valid initial states in which the system can start, i.e., the set $X_0$.
	\item The allowed set of input strings. In general, not every string in $U^*$ will be considered a valid input, and we can only define correctness when the input string is a valid one.
	We denote the set of valid input strings by $A$. 
	We have $A \subset U^*$.
	\item Perhaps most importantly, we must define properties of the output strings of $S$, i.e. how should $S$ behave?
	These properties are of two types:
	\begin{enumerate}
		\item We may define properties that must hold \emph{regardless} of the input strings that lead to them. 
		\item Or we may define properties that must hold only when the system is driven by given (sets of) input strings.
	\end{enumerate}
	In general, a property is an expression involving the the inputs and output of the system.
\end{itemize}
Together, we call this these three elements \emph{the system's specification}.
In what follows, we use $\phi$ to denote the properties that the system must satisfy.
Keep in mind that this is a requirement on the system when it is initialized correctly (i.e. $x_0 \in X_0$) and is driven correctly (i.e. $\bar{u} \in A$).

\emph{\textbf{Testing}} is a method for checking that the system does indeed obey its specification. 
In testing, an algorithm will 
\begin{itemize}
	\item initialize the system to some $x_0$ in $X_0$,
	\item generate sequences of input strings $\bar{u_k} \in A$, to which the system will produce output strings $\bar{y}_k$,
	\item a \emph{monitor} logs the output strings and determines whether the pair $(\bar{u}_k,\bar{y}_k)$ satisfies the specification or not.	
\end{itemize}

The generation algorithm and monitor are commonly referred to as a \emph{testbench} or test harness, and might be implemented in one piece of code. 
Because $X_0$ and $A$ may be (uncountably) infinite (or simply too large), the testbench must decide on how to intelligently choose a \emph{finite} number of $(x_0,\ub)$.
They must be chosen such that if the system does not produce wrong behavior with these pairs, then it is unlikely to produce errors under the \emph{full} valid set of $(x_0,\ub)$ pairs, namely, $X_0 \times A$.
This is the main challenge of testing: how to sample an infinite set of behaviors such that it is representative (in the above sense) of the full set of behaviors that $S$ is capable of?

Another important issue in testing is for how long to test the system: i.e. what should be the length of the $k^{th}$ string $\ub_k$? 
E.g., if $\ub_k$ has length 1000, the bug might manifest itself on $y_1\ldots y_{1001}$, but not $y_1\ldots y_{1000}$.

\emph{\textbf{Verification}} refers to formal verification.
In verification, 




